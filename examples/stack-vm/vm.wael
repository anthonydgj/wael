export let VirtualMachine = (program) => (

    # Import libraries
    Use("stack.wael") With (Stack);
    Use("bytes.wael") With (Byte);
    Use("map.wael") With (Map);
    Use("list.wael") With (List);

    # Instruction codes
    let CODE_PUSH = 1;
    let CODE_POP = 2;
    let CODE_ADD = 10;
    let CODE_SUBTRACT = 11;
    let CODE_MULTIPLY = 12;
    let CODE_DIVIDE = 13;
    let CODE_READ = 20; # TODO
    let CODE_JUMP = 21; # TODO
    let CODE_JUMP_IF_ZERO = 22; # TODO

    # Internal state
    let stack = Use(Stack());
    let instructions = Use(List(program));
    let instPtr = 0;
    let currentInstCode = undefined;

    # Helper functions
    let UnaryOperator = (s, fn) => (a = s:pop(); s:push(fn(a)); s);
    let BinaryOperator = (s, fn) => (a = s:pop(); b = s:pop(); s:push(fn(a, b)); s);

    # Instruction implementations
    let Push = () => (
        let nextValue = readNext();
        if (nextValue != undefined) then (
            stack:push(Byte(nextValue))
        ) else (
            undefined
        );
        nextValue
    ); 
    let Pop = () => (
        stack:pop()
    );
    let Add = () => (BinaryOperator(stack, (a, b) => (Byte(a + b))));
    let Subtract = () => (BinaryOperator(stack, (a, b) => (Byte(b - a))));
    let Multiply = () => (BinaryOperator(stack, (a, b) => (Byte(a * b))));
    let Divide = () => (BinaryOperator(stack, (a, b) => (Byte(b / a))));

    # Instruction lookup
    let Instruction = (code) => (
        if (code == CODE_PUSH) then (Push) else (
        if (code == CODE_POP) then (Pop) else (
        if (code == CODE_ADD) then (Add) else (
        if (code == CODE_SUBTRACT) then (Subtract) else (
        if (code == CODE_MULTIPLY) then (Multiply) else (
        if (code == CODE_DIVIDE) then (Divide) else (
            () => ()
        ))))))
    );

    # Read the next instruction
    let readNext = () => (
        let instCode = instructions:get(instPtr);
        instPtr = instPtr + 1;
        instCode
    );

    # Execute the next instruction 
    export let step = () => (
        let instruction = Instruction(currentInstCode);
        if (instruction != undefined) then (instruction()) else (false);
        stack()
    );

    # Process all instructions
    export let start = () => (
        Generate 
            (i => (currentInstCode = readNext(); currentInstCode != undefined)) 
            (i => (step(); 1 1))
    );

    # Default 
    () => (stack())
);
